<!DOCTYPE html>
<html>
    <script src="convnetjs.js"></script>
    <script>

        var image_width = 68;
        var image_height = 68;
        var image_channels = 3;
        var correct = total = 0;
        var net, trainer;
        var maxmin = function (x) {
            var maxv = Math.max.apply(null, x);
            var minv = Math.min.apply(null, x);
            var dv = maxv - minv;
            return {minv: minv, maxv: maxv, dv: dv};
        };
        var f2t = function (x) {
            return x.toFixed(2);
        };
        var draw_activations_COLOR = function (elt, A, scale, grads) {

            var s = scale || 2; // scale
            var draw_grads = false;
            if (typeof (grads) !== 'undefined')
                draw_grads = grads;

            // get max and min activation to scale the maps automatically
            var w = draw_grads ? A.dw : A.w;
            var mm = maxmin(w);

            var canv = document.createElement('canvas');
            canv.className = 'actmap';
            var W = A.sx * s;
            var H = A.sy * s;
            canv.width = W;
            canv.height = H;
            var ctx = canv.getContext('2d');
            var g = ctx.createImageData(W, H);
            for (var d = 0; d < 3; d++) {
                for (var x = 0; x < A.sx; x++) {
                    for (var y = 0; y < A.sy; y++) {
                        if (draw_grads) {
                            var dval = Math.floor((A.get_grad(x, y, d) - mm.minv) / mm.dv * 255);
                        } else {
                            var dval = Math.floor((A.get(x, y, d) - mm.minv) / mm.dv * 255);
                        }
                        for (var dx = 0; dx < s; dx++) {
                            for (var dy = 0; dy < s; dy++) {
                                var pp = ((W * (y * s + dy)) + (dx + x * s)) * 4;
                                g.data[pp + d] = dval;
                                if (d === 0)
                                    g.data[pp + 3] = 255; // alpha channel
                            }
                        }
                    }
                }
            }
            ctx.putImageData(g, 0, 0);
            elt.appendChild(canv);
        };
// elt is the element to add all the canvas activation drawings into
// A is the Vol() to use
// scale is a multiplier to make the visualizations larger. Make higher for larger pictures
// if grads is true then gradients are used instead
        var draw_activations = function (elt, A, scale, grads) {

            var s = scale || 2; // scale
            var draw_grads = false;
            if (typeof (grads) !== 'undefined')
                draw_grads = grads;

            // get max and min activation to scale the maps automatically
            var w = draw_grads ? A.dw : A.w;
            var mm = maxmin(w);

            // create the canvas elements, draw and add to DOM
            for (var d = 0; d < A.depth; d++) {

                var canv = document.createElement('canvas');
                canv.className = 'actmap';
                var W = A.sx * s;
                var H = A.sy * s;
                canv.width = W;
                canv.height = H;
                var ctx = canv.getContext('2d');
                var g = ctx.createImageData(W, H);

                for (var x = 0; x < A.sx; x++) {
                    for (var y = 0; y < A.sy; y++) {
                        if (draw_grads) {
                            var dval = Math.floor((A.get_grad(x, y, d) - mm.minv) / mm.dv * 255);
                        } else {
                            var dval = Math.floor((A.get(x, y, d) - mm.minv) / mm.dv * 255);
                        }
                        for (var dx = 0; dx < s; dx++) {
                            for (var dy = 0; dy < s; dy++) {
                                var pp = ((W * (y * s + dy)) + (dx + x * s)) * 4;
                                for (var i = 0; i < 3; i++) {
                                    g.data[pp + i] = dval;
                                } // rgb
                                g.data[pp + 3] = 255; // alpha channel
                            }
                        }
                    }
                }
                ctx.putImageData(g, 0, 0);
                elt.appendChild(canv);
            }
        };
        var visualize_activations = function (net, elt) {

            // clear the element
            elt.innerHTML = "";

            // show activations in each layer
            var N = net.layers.length;
            for (var i = 0; i < N; i++) {
                var L = net.layers[i];

                var layer_div = document.createElement('div');

                // visualize activations
                var activations_div = document.createElement('div');
                activations_div.appendChild(document.createTextNode('Activations:'));
                activations_div.appendChild(document.createElement('br'));
                activations_div.className = 'layer_act';
                var scale = 2;
                if (L.layer_type === 'softmax' || L.layer_type === 'fc')
                    scale = 10; // for softmax

                // HACK to draw in color in input layer
                if (i === 0) {
                    draw_activations_COLOR(activations_div, L.out_act, scale);
                    draw_activations_COLOR(activations_div, L.out_act, scale, true);

                    /*
                     // visualize positive and negative components of the gradient separately
                     var dd = L.out_act.clone();
                     var ni = L.out_act.w.length;
                     for(var q=0;q<ni;q++) { var dwq = L.out_act.dw[q]; dd.w[q] = dwq > 0 ? dwq : 0.0; }
                     draw_activations_COLOR(activations_div, dd, scale);
                     for(var q=0;q<ni;q++) { var dwq = L.out_act.dw[q]; dd.w[q] = dwq < 0 ? -dwq : 0.0; }
                     draw_activations_COLOR(activations_div, dd, scale);
                     */

                    /*
                     // visualize what the network would like the image to look like more
                     var dd = L.out_act.clone();
                     var ni = L.out_act.w.length;
                     for(var q=0;q<ni;q++) { var dwq = L.out_act.dw[q]; dd.w[q] -= 20*dwq; }
                     draw_activations_COLOR(activations_div, dd, scale);
                     */

                    /*
                     // visualize gradient magnitude
                     var dd = L.out_act.clone();
                     var ni = L.out_act.w.length;
                     for(var q=0;q<ni;q++) { var dwq = L.out_act.dw[q]; dd.w[q] = dwq*dwq; }
                     draw_activations_COLOR(activations_div, dd, scale);
                     */

                } else {
                    draw_activations(activations_div, L.out_act, scale);
                }

                // visualize data gradients
                if (L.layer_type !== 'softmax' && L.layer_type !== 'input') {
                    var grad_div = document.createElement('div');
                    grad_div.appendChild(document.createTextNode('Activation Gradients:'));
                    grad_div.appendChild(document.createElement('br'));
                    grad_div.className = 'layer_grad';
                    var scale = 2;
                    if (L.layer_type === 'softmax' || L.layer_type === 'fc')
                        scale = 10; // for softmax
                    draw_activations(grad_div, L.out_act, scale, true);
                    activations_div.appendChild(grad_div);
                }

                // visualize filters if they are of reasonable size
                if (L.layer_type === 'conv') {
                    var filters_div = document.createElement('div');
                    if (L.filters[0].sx > 3) {
                        // actual weights
                        filters_div.appendChild(document.createTextNode('Weights:'));
                        filters_div.appendChild(document.createElement('br'));
                        for (var j = 0; j < L.filters.length; j++) {
                            // HACK to draw in color for first layer conv filters
                            if (i === 1) {
                                draw_activations_COLOR(filters_div, L.filters[j], 2);
                            } else {
                                filters_div.appendChild(document.createTextNode('('));
                                draw_activations(filters_div, L.filters[j], 2);
                                filters_div.appendChild(document.createTextNode(')'));
                            }
                        }
                        // gradients
                        filters_div.appendChild(document.createElement('br'));
                        filters_div.appendChild(document.createTextNode('Weight Gradients:'));
                        filters_div.appendChild(document.createElement('br'));
                        for (var j = 0; j < L.filters.length; j++) {
                            if (i === 1) {
                                draw_activations_COLOR(filters_div, L.filters[j], 2, true);
                            }
                            else {
                                filters_div.appendChild(document.createTextNode('('));
                                draw_activations(filters_div, L.filters[j], 2, true);
                                filters_div.appendChild(document.createTextNode(')'));
                            }
                        }
                    } else {
                        filters_div.appendChild(document.createTextNode('Weights hidden, too small'));
                    }
                    activations_div.appendChild(filters_div);
                }
                layer_div.appendChild(activations_div);

                // print some stats on left of the layer
                layer_div.className = 'layer ' + 'lt' + L.layer_type;
                var title_div = document.createElement('div');
                title_div.className = 'ltitle'
                var t = L.layer_type + ' (' + L.out_sx + 'x' + L.out_sy + 'x' + L.out_depth + ')';
                title_div.appendChild(document.createTextNode(t));
                layer_div.appendChild(title_div);

                if (L.layer_type === 'conv') {
                    var t = 'filter size ' + L.filters[0].sx + 'x' + L.filters[0].sy + 'x' + L.filters[0].depth + ', stride ' + L.stride;
                    layer_div.appendChild(document.createTextNode(t));
                    layer_div.appendChild(document.createElement('br'));
                }
                if (L.layer_type === 'pool') {
                    var t = 'pooling size ' + L.sx + 'x' + L.sy + ', stride ' + L.stride;
                    layer_div.appendChild(document.createTextNode(t));
                    layer_div.appendChild(document.createElement('br'));
                }

                // find min, max activations and display them
                var mma = maxmin(L.out_act.w);
                var t = 'max activation: ' + f2t(mma.maxv) + ', min: ' + f2t(mma.minv);
                layer_div.appendChild(document.createTextNode(t));
                layer_div.appendChild(document.createElement('br'));

                var mma = maxmin(L.out_act.dw);
                var t = 'max gradient: ' + f2t(mma.maxv) + ', min: ' + f2t(mma.minv);
                layer_div.appendChild(document.createTextNode(t));
                layer_div.appendChild(document.createElement('br'));

                // number of parameters
                if (L.layer_type === 'conv' || L.layer_type === 'local') {
                    var tot_params = L.sx * L.sy * L.in_depth * L.filters.length + L.filters.length;
                    var t = 'parameters: ' + L.filters.length + 'x' + L.sx + 'x' + L.sy + 'x' + L.in_depth + '+' + L.filters.length + ' = ' + tot_params;
                    layer_div.appendChild(document.createTextNode(t));
                    layer_div.appendChild(document.createElement('br'));
                }
                if (L.layer_type === 'fc') {
                    var tot_params = L.num_inputs * L.filters.length + L.filters.length;
                    var t = 'parameters: ' + L.filters.length + 'x' + L.num_inputs + '+' + L.filters.length + ' = ' + tot_params;
                    layer_div.appendChild(document.createTextNode(t));
                    layer_div.appendChild(document.createElement('br'));
                }

                // css madness needed here...
                var clear = document.createElement('div');
                clear.className = 'clear';
                layer_div.appendChild(clear);

                elt.appendChild(layer_div);
            }
        };



        var add = function (a, b) {
            return a + b;
        };


        var sampletest = function (img_data) {
            var p = img_data.data;
            var x = new convnetjs.Vol(image_width, image_height, image_channels, 0.0);
            var W = image_width * image_height;
            var j = 0;
            for (var dc = 0; dc < image_channels; dc++) {
                for (var xc = 0; xc < image_width; xc++) {
                    for (var yc = 0; yc < image_height; yc++) {
                        var ix = (xc + yc * image_width) * 4 + dc;
                        x.set(xc, yc, dc, p[ix] / 255.0 - 0.5);
                    }
                }
            }
            return x;
        };

        var loadimg = function (callback) {
            var img = new Image;
            var rand = Math.floor((Math.random() * 10));
            img.onload = function () {
                var data_canvas = document.createElement('canvas');
                data_canvas.width = img.width;
                data_canvas.height = img.height;
                var data_ctx = data_canvas.getContext("2d");
                data_ctx.drawImage(img, 0, 0); // copy it over... bit wasteful :(
                var img_data = data_ctx.getImageData(0, 0, data_canvas.width, data_canvas.height);
                //testout.appendChild(data_canvas);
                callback(sampletest(img_data), rand);
            };
            img.src = "/mavenproject1/Image?val=" + rand;
        };

        var step_num = 0;
        var step = function (x, label) {
            var stats = trainer.train(x, label);
            var labelhat = net.getPrediction();
            correct = correct + (labelhat === label ? 1.0 : 0);
            total = total + 1;

            if (step_num % 100 === 0) {
                output.innerHTML = "acc: " + (correct / total);
                visualize_activations(net, vis_elt);
            }
            //console.log(stats);
            step_output.innerHTML = "step: " + step_num;
            step_num++;
        };

        var loadsampletest = function (callback) {
            loadimg(function (x, label) {
                //console.log(x);
                //console.log(label);

                var sum = x.w.reduce(add, 0);
                //console.log(sum);

                callback(x, label);
            });
        };

        var start = function (val, img) {
            var layer_defs = [];
            layer_defs.push({type: 'input', out_sx: 68, out_sy: 68, out_depth: 3}); // declare size of input
            //
            layer_defs.push({type: 'conv', sx: 5, filters: 8, stride: 1, pad: 2, activation: 'relu'});
            layer_defs.push({type: 'pool', sx: 2, stride: 2});
            layer_defs.push({type: 'conv', sx: 5, filters: 16, stride: 1, pad: 2, activation: 'relu'});
            layer_defs.push({type: 'pool', sx: 3, stride: 3});
            layer_defs.push({type: 'softmax', num_classes: 10});
//            // output Vol is of size 32x32x3 here
//            layer_defs.push({type: 'conv', sx: 5, filters: 16, stride: 1, pad: 2, activation: 'relu'});
//            // the layer will perform convolution with 16 kernels, each of size 5x5.
//            // the input will be padded with 2 pixels on all sides to make the output Vol of the same size
//            // output Vol will thus be 32x32x16 at this point
//            layer_defs.push({type: 'pool', sx: 2, stride: 2});
//            // output Vol is of size 16x16x16 here
//            layer_defs.push({type: 'conv', sx: 5, filters: 20, stride: 1, pad: 2, activation: 'relu'});
//            // output Vol is of size 16x16x20 here
//            layer_defs.push({type: 'pool', sx: 2, stride: 2});
//            // output Vol is of size 8x8x20 here
//            layer_defs.push({type: 'conv', sx: 5, filters: 20, stride: 1, pad: 2, activation: 'relu'});
//            // output Vol is of size 8x8x20 here
//            layer_defs.push({type: 'pool', sx: 2, stride: 2});
//            // output Vol is of size 4x4x20 here
//            layer_defs.push({type: 'softmax', num_classes: 10});
//            // output Vol is of size 1x1x10 here

            net = new convnetjs.Net();
            net.makeLayers(layer_defs);

            trainer = new convnetjs.SGDTrainer(net, {method: 'adadelta', batch_size: 1, l2_decay: 0.001});


            // helpful utility for converting images into Vols is included
            //var x = convnetjs.img_to_vol(img)
            //output_probabilities_vol = net.forward(x)

        };

        var paused = false;
        var load_and_step = function () {
            if (paused)
                return;

            loadsampletest(step);

            //setTimeout(load_and_step, 0); // schedule the next iteration
        };

        var load = function () {
            start();
            setInterval(load_and_step, 0); // lets go!
        };
        var pause = function () {
            if (paused) {
                pausebtn.innerHTML = "Start";
                paused = false;
            } else {
                pausebtn.innerHTML = "Pause";
                paused = true;
            }
        };
    </script>
    <body  onload="load()">
        <div>
            <img id="some_image"/>
        </div>
        <button id="pausebtn" onclick="pause()">Pause</button>
        <div id ="testout"></div>
        <div id="output"></div>
        <div id="step_output"></div>
        <div id="vis_elt"></div>
    </body>

</html>
